"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidateResponseSchema = exports.ValidateBodySchema = exports.ChannelDataSchema = exports.ChannelLogSchema = exports.ReimportBodySchema = exports.AddChannelLogBodySchema = exports.CreateChannelResponseSchema = exports.CreateChannelBodySchema = void 0;
const typebox_1 = require("@sinclair/typebox");
const channel_info_1 = require("../channel-info");
exports.CreateChannelBodySchema = typebox_1.Type.Object({
    subscriptionPassword: typebox_1.Type.Optional(typebox_1.Type.String({
        minLength: 8,
        description: 'If a subscriptionPassword is set, all data is encrypted with the password. It need to be made sure, the subscription password is sent when interacting with the APIs of the channel-service and subscription-service.'
    })),
    topics: typebox_1.Type.Array(channel_info_1.TopicSchema),
    hasPresharedKey: typebox_1.Type.Optional(typebox_1.Type.Boolean({
        description: 'If the channel has a preshared key (hasPresharedKey=true) but non is set in the presharedKey property it will be generated by the api.'
    })),
    seed: typebox_1.Type.Optional(typebox_1.Type.String({
        minLength: 1,
        description: 'If left empty the api will generate a seed automatically. Always store your seed otherwise the data can not be reimported.'
    })),
    presharedKey: typebox_1.Type.Optional(typebox_1.Type.String({
        minLength: 32,
        maxLength: 32,
        description: 'If the channel has a preshared key (hasPresharedKey=true) but non is defined here the presharedKey will be generated by the api.'
    }))
});
exports.CreateChannelResponseSchema = typebox_1.Type.Object({
    seed: typebox_1.Type.Optional(typebox_1.Type.String({ minLength: 1 })),
    channelAddress: typebox_1.Type.String({ minLength: 105, maxLength: 105 }),
    presharedKey: typebox_1.Type.Optional(typebox_1.Type.String({
        minLength: 32,
        maxLength: 32
    }))
});
exports.AddChannelLogBodySchema = typebox_1.Type.Object({
    type: typebox_1.Type.Optional(typebox_1.Type.String({ minLength: 1, description: 'Public available type.' })),
    created: typebox_1.Type.Optional(typebox_1.Type.String({ format: 'date-time', description: 'Public available date.' })),
    metadata: typebox_1.Type.Optional(typebox_1.Type.Any({ description: 'Public available metadata.' })),
    publicPayload: typebox_1.Type.Optional(typebox_1.Type.Any({ description: 'Public available payload.' })),
    payload: typebox_1.Type.Optional(typebox_1.Type.Any({ description: 'Payload is stored encrypted in the channel.' }))
});
exports.ReimportBodySchema = typebox_1.Type.Object({
    seed: typebox_1.Type.Optional(typebox_1.Type.String({ minLength: 1 })),
    subscriptionPassword: typebox_1.Type.Optional(typebox_1.Type.String({
        minLength: 8,
        description: 'If a subscriptionPassword is set, all data is encrypted with the password. It need to be made sure, the subscription password is sent when interacting with the APIs of the channel-service and subscription-service.'
    })) // TODO#156 use to decrypt/encrypt data and state
});
exports.ChannelLogSchema = exports.AddChannelLogBodySchema;
exports.ChannelDataSchema = typebox_1.Type.Object({
    link: typebox_1.Type.String(),
    imported: typebox_1.Type.Optional(typebox_1.Type.String({ format: 'date-time', description: 'Date when the data was imported from the tangle into the cached database.' })),
    messageId: typebox_1.Type.Optional(typebox_1.Type.String({ description: 'Message id can be used to search for the message in an IOTA explorer.' })),
    log: exports.ChannelLogSchema
});
exports.ValidateBodySchema = typebox_1.Type.Array(exports.ChannelDataSchema);
exports.ValidateResponseSchema = typebox_1.Type.Array(typebox_1.Type.Object({
    link: typebox_1.Type.String(),
    isValid: typebox_1.Type.Boolean(),
    error: typebox_1.Type.Optional(typebox_1.Type.String()),
    tangleLog: typebox_1.Type.Optional(typebox_1.Type.Any())
}));
//# sourceMappingURL=channel-bodies.js.map