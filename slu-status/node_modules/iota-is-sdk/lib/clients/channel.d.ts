import { ChannelData } from '../models/types/channel-data';
import { ChannelInfo, ChannelInfoSearch } from '../models/types/channel-info';
import { ClientConfig } from '../models/clientConfig';
import { AddChannelLogBody, CreateChannelBody, CreateChannelResponse, ReimportBody, ValidateBody, ValidateResponse, AuthorizeSubscriptionBody, AuthorizeSubscriptionResponse, RequestSubscriptionBody, RequestSubscriptionResponse, RevokeSubscriptionBody } from '../models/types/request-response-bodies';
import { Subscription as SubscriptionInternal, SubscriptionUpdate } from '../models/types/subscription';
import { BaseClient } from './base';
export declare class ChannelClient extends BaseClient {
    constructor(config?: ClientConfig);
    /**
     * Create a new channel. An author can create a new channel with specific topics where other clients can subscribe to.
     * @param channelData
     * @returns
     */
    create(data: CreateChannelBody): Promise<CreateChannelResponse>;
    /**
     * Write data to a channel with address channel address. Write permission is mandatory. The type and metadata fields are not encrypted to have a possibility to search for events. The payload is stored encrypted for encrypted channels.
     * @param channelAddress
     * @param data
     * @returns
     */
    write(address: string, data: AddChannelLogBody): Promise<ChannelData>;
    /**
     * Get data from the channel with address channel address. The first possible message a subscriber can receive is the time the subscription got approved all messages before are not received. Read permission is mandatory.
     * @param channelAddress
     * @param limit
     * @param index
     * @param asc
     * @param startDate
     * @param endDate
     * @returns
     */
    read(channelAddress: string, channelOptions?: {
        limit?: number;
        index?: number;
        asc?: boolean;
        startDate?: Date;
        endDate?: Date;
    }): Promise<ChannelData[]>;
    /**
     * Get all data of a channel using a shared key (in case of encrypted channels). Mainly used from auditors to evaluate a log stream.
     * @param channelAddress
     * @param presharedKey
     * @returns
     */
    readHistory(channelAddress: string, presharedKey: string): Promise<ChannelData[]>;
    /**
     * Validates channel data by comparing the log of each link with the data on the tangle.
     * @param address
     * @param data
     * @returns
     */
    validate(address: string, data: ValidateBody): Promise<ValidateResponse>;
    /**
     * The user can decide to re-import the data from the Tangle into the database. A reason for it could be a malicious state of the data.
     * @param address
     * @param data
     * @returns
     */
    reimport(address: string, data: ReimportBody): Promise<null>;
    /**
     * Search for a channel. A client can search for a channel which it is interested in.
     * @param author
     * @param topicType
     * @param topicSource
     * @param created
     * @param latestMessage
     * @param limit
     * @param index
     * @returns
     */
    search(searchCriteria: ChannelInfoSearch): Promise<ChannelInfo[]>;
    /**
     * Get information about a channel with address channel-address.
     * @param address
     * @returns
     */
    info(address: string): Promise<ChannelInfo>;
    /**
     * Add an existing channel into the database. Clients are able to add existing channels into the database so others can subscribe to them. This will be automatically called when a channel will be created.
     * @param channel
     * @returns
     */
    add(channel: ChannelInfo): Promise<null>;
    /**
     * Update channel information. The author of a channel can update topics of a channel.
     * @param channel
     * @returns
     */
    update(channel: ChannelInfo): Promise<null>;
    /**
     * Delete information of a channel with address channel-address. The author of a channel can delete its entry in the database. In this case all subscriptions will be deleted and the channel won’t be found in the system anymore. The data & channel won’t be deleted from the IOTA Tangle since its data is immutable on the tangle!
     * @param address
     * @returns
     */
    remove(address: string): Promise<null>;
    /**
     * Get all subscriptions of a channel. Use the is-authorized query parameter to filter for authorized subscriptions.
     * @param channelAddress
     * @param isAuthorized
     * @returns
     */
    findAllSubscriptions(channelAddress: string, isAuthorized?: boolean): Promise<SubscriptionInternal[]>;
    /**
     * Get a subscription of a channel by identity id.
     * @param channelAddress
     * @param id
     * @returns
     */
    findSubscription(channelAddress: string, id: string): Promise<SubscriptionInternal>;
    /**
     * Request subscription to a channel with address channel-address. A client can request a subscription to a channel which it then is able to read/write from.
     * @param channelAddress
     * @param options
     * @returns
     */
    requestSubscription(channelAddress: string, options?: RequestSubscriptionBody): Promise<RequestSubscriptionResponse>;
    /**
     * Authorize a subscription to a channel with address channel-address. The author of a channel can authorize a subscriber to read/write from a channel. Eventually after verifying its identity (using the Ecommerce-SSI Bridge).
     * @param channelAddress
     * @param authorization
     * @returns
     */
    authorizeSubscription(channelAddress: string, subscriptionIdentifier: AuthorizeSubscriptionBody): Promise<AuthorizeSubscriptionResponse>;
    /**
     * Revoke subscription to a channel. Only the author of a channel can revoke a subscription from a channel.
     * @param channelAddress
     * @param subscriptionIdentifier
     * @returns
     */
    revokeSubscription(channelAddress: string, subscriptionIdentifier: RevokeSubscriptionBody): Promise<null>;
    /**
     * Adds an existing subscription (e.g. the subscription was not created with the api but locally.)
     * @param channelAddress
     * @param id
     * @param subscription
     * @returns
     */
    addSubscription(channelAddress: string, id: string, subscription: SubscriptionInternal): Promise<SubscriptionInternal>;
    /**
     * Updates an existing subscription.
     * @param channelAddress
     * @param id
     * @param updatedSubscription
     * @returns
     */
    updateSubscription(channelAddress: string, id: string, updatedSubscription: SubscriptionUpdate): Promise<null>;
    /**
     * Deletes an existing subscription.
     * @param channelAddress
     * @param id
     * @returns
     */
    removeSubscription(channelAddress: string, id: string): Promise<null>;
}
//# sourceMappingURL=channel.d.ts.map