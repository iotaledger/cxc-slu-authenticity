import { BaseClient } from './base';
import { ClientConfig } from '../models/clientConfig';
import { IdentityInternal, IdentityJson, LatestIdentityJson, VerifiableCredentialJson } from '../models/types/identity';
import { RevokeVerificationBody } from '../models/types/request-response-bodies';
import { User, UserType } from '../models/types/user';
import { CredentialTypes, VerifiableCredentialInternal } from '../models/types/verification';
import { searchCriteria } from '../models/searchCriteria';
export declare class IdentityClient extends BaseClient {
    constructor(config?: ClientConfig);
    /**
     * Create a new decentralized digital identity (DID). Identity DID document is signed and published to the ledger (IOTA Tangle). A digital identity can represent an individual, an organization or an object. The privateAuthKey controlling the identity is returned. It is recommended to securely (encrypt) store the privateAuthKey locally, since it is not stored on the APIs Bridge.
     * @param username
     * @param claimType defaults to UserType.Person
     * @param claim
     * @returns
     */
    create(username?: string, claimType?: UserType, claim?: any): Promise<IdentityJson>;
    /**
     * Search for identities in the system and returns a list of existing identities.
     * @param username
     * @returns
     */
    search({ type, username, registrationDate, limit, index }: searchCriteria): Promise<User[]>;
    /**
     * Get information (including attached credentials) about a specific identity using the identity-id (DID identifier).
     * @param id
     * @returns
     */
    find(id: string): Promise<User>;
    /**
     * Register an existing identity into the Bridge. This can be used if the identity already exists or it was only created locally. Registering an identity in the Bridge makes it possible to search for it by using some of the identity attributes, i.e., the username.
     * @param identity
     * @returns
     */
    add(identity: IdentityInternal): Promise<null>;
    /**
     * Update claim of a registered identity.
     * @param identity
     * @returns
     */
    update(identity: IdentityInternal): Promise<null>;
    /**
     * Removes an identity from the Bridge. An identity can only delete itself and is not able to delete other identities. Administrators are able to remove other identities. The identity cannot be removed from the immutable IOTA Tangle but only at the Bridge. Also the identity credentials will remain and the identity is still able to interact with other bridges.
     * @param id
     * @param revokeCredentials
     * @returns Null
     */
    remove(id: string, revokeCredentials?: boolean): Promise<null>;
    /**
     * Get the latest version of an identity document (DID) from the IOTA Tangle.
     * @param id
     * @returns
     */
    latestDocument(id: string): Promise<LatestIdentityJson>;
    /**
     * Adds Trusted Root identity identifiers (DIDs). Trusted roots are DIDs of identities which are trusted by the Bridge. This identity DIDs can be DIDs of other organizations. By adding them to the list Trusted Roots their Verifiable Credentials (VCs) are automatically trusted when checking at the Bridge.
     * @param trustedAuthority
     * @returns
     */
    addTrustedAuthority(trustedRootId: string): Promise<null>;
    /**
     * Returns a list of Trusted Root identity identifiers (DIDs). Trusted roots are DIDs of identities which are trusted by the Bridge. This identity DIDs can be DIDs of other organizations. By adding them to the list Trusted Roots their Verifiable Credentials (VCs) are automatically trusted when checking at the Bridge.
     * @returns
     */
    getTrustedAuthorities(): Promise<string[]>;
    /**
     * Remove Trusted Root identity identifiers (DIDs). Trusted roots are DIDs of identities which are trusted by the Bridge. This identity DIDs can be DIDs of other organizations. By adding them to the list Trusted Roots their Verifiable Credentials (VCs) are automatically trusted when checking at the Bridge.
     * @param trustedAuthorityId
     * @returns
     */
    removeTrustedAuthority(trustedAuthorityId: string): Promise<null>;
    /**
     * Verify the authenticity of an identity (of an individual, organization or object) and issue a credential stating the identity verification status. Only previously verified identities (based on a network of trust) with assigned privileges can verify other identities. Having a verified identity provides the opportunity for other identities to identify and verify a the entity they interact to.
     * @param initiatorVC
     * @param targetDid
     * @param claim
     * @returns
     */
    createCredential(initiatorVC: VerifiableCredentialInternal | undefined, targetDid: string, credentialType: CredentialTypes, claimType: UserType, claim?: any): Promise<VerifiableCredentialJson>;
    /**
     * Check the verifiable credential of an identity. Validates the signed verifiable credential against the Issuer information stored onto the IOTA Tangle and checks if the issuer identity (DID) contained in the credential is from a trusted root.
     * @param credential
     * @returns
     */
    checkCredential(credential: VerifiableCredentialInternal): Promise<{
        isVerified: boolean;
    }>;
    /**
     * Revoke one specific verifiable credential of an identity. In the case of individual and organization identities the reason could be that the user has left the organization. Only organization admins (with verified identities) or the identity owner itself can do that.
     * @param credential
     * @returns
     */
    revokeCredential(credential: RevokeVerificationBody): Promise<null>;
}
//# sourceMappingURL=identity.d.ts.map