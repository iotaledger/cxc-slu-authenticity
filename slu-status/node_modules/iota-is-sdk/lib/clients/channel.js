"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelClient = void 0;
const base_1 = require("./base");
class ChannelClient extends base_1.BaseClient {
    constructor(config = {}) {
        super(config);
    }
    /**
     * Create a new channel. An author can create a new channel with specific topics where other clients can subscribe to.
     * @param channelData
     * @returns
     */
    create(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post('channels/create', data);
        });
    }
    /**
     * Write data to a channel with address channel address. Write permission is mandatory. The type and metadata fields are not encrypted to have a possibility to search for events. The payload is stored encrypted for encrypted channels.
     * @param channelAddress
     * @param data
     * @returns
     */
    write(address, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`channels/logs/${address}`, data);
        });
    }
    /**
     * Get data from the channel with address channel address. The first possible message a subscriber can receive is the time the subscription got approved all messages before are not received. Read permission is mandatory.
     * @param channelAddress
     * @param limit
     * @param index
     * @param asc
     * @param startDate
     * @param endDate
     * @returns
     */
    read(channelAddress, channelOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const { limit, index, asc, startDate, endDate } = channelOptions || {};
            const param1 = startDate !== undefined ? { 'start-date': startDate } : {};
            const param2 = endDate !== undefined ? { 'end-date': endDate } : {};
            const param3 = asc !== undefined ? { asc } : { asc: true };
            const channelData = yield this.get(`channels/logs/${channelAddress}`, Object.assign(Object.assign({ limit, index, param3 }, param1), param2));
            // Temporary fix to replace null values with undefined
            // TODO: fix this in backend
            return channelData.map((data) => {
                Object.keys(data === null || data === void 0 ? void 0 : data.log).forEach((key) => {
                    if ((data === null || data === void 0 ? void 0 : data.log[key]) === null) {
                        data.log[key] = undefined;
                    }
                });
                return data;
            });
        });
    }
    /**
     * Get all data of a channel using a shared key (in case of encrypted channels). Mainly used from auditors to evaluate a log stream.
     * @param channelAddress
     * @param presharedKey
     * @returns
     */
    readHistory(channelAddress, presharedKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`channels/history/${channelAddress}`, {
                'preshared-key': presharedKey
            });
        });
    }
    /**
     * Validates channel data by comparing the log of each link with the data on the tangle.
     * @param address
     * @param data
     * @returns
     */
    validate(address, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`channels/validate/${address}`, data);
        });
    }
    /**
     * The user can decide to re-import the data from the Tangle into the database. A reason for it could be a malicious state of the data.
     * @param address
     * @param data
     * @returns
     */
    reimport(address, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`re-import/${address}`, data);
        });
    }
    /**
     * Search for a channel. A client can search for a channel which it is interested in.
     * @param author
     * @param topicType
     * @param topicSource
     * @param created
     * @param latestMessage
     * @param limit
     * @param index
     * @returns
     */
    search(searchCriteria) {
        return __awaiter(this, void 0, void 0, function* () {
            const { author, authorId, topicType, topicSource, created, latestMessage, limit, index } = searchCriteria;
            const param1 = topicType !== undefined ? { 'topic-type': topicType } : {};
            const param2 = topicSource !== undefined ? { 'topic-source': topicSource } : {};
            const param3 = latestMessage !== undefined ? { 'latest-message': latestMessage } : {};
            const param4 = authorId !== undefined ? { 'author-id': authorId } : {};
            return yield this.get('channel-info/search', Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ author }, param1), param2), { created }), param3), param4), { limit,
                index }));
        });
    }
    /**
     * Get information about a channel with address channel-address.
     * @param address
     * @returns
     */
    info(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`channel-info/channel/${address}`);
        });
    }
    /**
     * Add an existing channel into the database. Clients are able to add existing channels into the database so others can subscribe to them. This will be automatically called when a channel will be created.
     * @param channel
     * @returns
     */
    add(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post('channel-info/channel', channel);
        });
    }
    /**
     * Update channel information. The author of a channel can update topics of a channel.
     * @param channel
     * @returns
     */
    update(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.put('channel-info/channel', channel);
        });
    }
    /**
     * Delete information of a channel with address channel-address. The author of a channel can delete its entry in the database. In this case all subscriptions will be deleted and the channel won’t be found in the system anymore. The data & channel won’t be deleted from the IOTA Tangle since its data is immutable on the tangle!
     * @param address
     * @returns
     */
    remove(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.delete(`channel-info/channel/${address}`, {});
        });
    }
    /**
     * Get all subscriptions of a channel. Use the is-authorized query parameter to filter for authorized subscriptions.
     * @param channelAddress
     * @param isAuthorized
     * @returns
     */
    findAllSubscriptions(channelAddress, isAuthorized) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = isAuthorized !== undefined ? { 'is-authorized': isAuthorized } : {};
            return yield this.get(`subscriptions/${channelAddress}`, params);
        });
    }
    /**
     * Get a subscription of a channel by identity id.
     * @param channelAddress
     * @param id
     * @returns
     */
    findSubscription(channelAddress, id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`subscriptions/${channelAddress}/${id}`, {});
        });
    }
    /**
     * Request subscription to a channel with address channel-address. A client can request a subscription to a channel which it then is able to read/write from.
     * @param channelAddress
     * @param options
     * @returns
     */
    requestSubscription(channelAddress, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`subscriptions/request/${channelAddress}`, options);
        });
    }
    /**
     * Authorize a subscription to a channel with address channel-address. The author of a channel can authorize a subscriber to read/write from a channel. Eventually after verifying its identity (using the Ecommerce-SSI Bridge).
     * @param channelAddress
     * @param authorization
     * @returns
     */
    authorizeSubscription(channelAddress, subscriptionIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`subscriptions/authorize/${channelAddress}`, subscriptionIdentifier);
        });
    }
    /**
     * Revoke subscription to a channel. Only the author of a channel can revoke a subscription from a channel.
     * @param channelAddress
     * @param subscriptionIdentifier
     * @returns
     */
    revokeSubscription(channelAddress, subscriptionIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`subscriptions/revoke/${channelAddress}`, subscriptionIdentifier);
        });
    }
    /**
     * Adds an existing subscription (e.g. the subscription was not created with the api but locally.)
     * @param channelAddress
     * @param id
     * @param subscription
     * @returns
     */
    addSubscription(channelAddress, id, subscription) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post(`subscriptions/${channelAddress}/${id}`, subscription);
        });
    }
    /**
     * Updates an existing subscription.
     * @param channelAddress
     * @param id
     * @param updatedSubscription
     * @returns
     */
    updateSubscription(channelAddress, id, updatedSubscription) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.put(`subscriptions/${channelAddress}/${id}`, updatedSubscription);
        });
    }
    /**
     * Deletes an existing subscription.
     * @param channelAddress
     * @param id
     * @returns
     */
    removeSubscription(channelAddress, id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.delete(`subscriptions/${channelAddress}/${id}`, {});
        });
    }
}
exports.ChannelClient = ChannelClient;
//# sourceMappingURL=channel.js.map