"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IdentityClient = void 0;
const base_1 = require("./base");
const user_1 = require("../models/types/user");
class IdentityClient extends base_1.BaseClient {
    constructor(config = {}) {
        super(config);
    }
    /**
     * Create a new decentralized digital identity (DID). Identity DID document is signed and published to the ledger (IOTA Tangle). A digital identity can represent an individual, an organization or an object. The privateAuthKey controlling the identity is returned. It is recommended to securely (encrypt) store the privateAuthKey locally, since it is not stored on the APIs Bridge.
     * @param username
     * @param claimType defaults to UserType.Person
     * @param claim
     * @returns
     */
    create(username, claimType = user_1.UserType.Person, claim) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post('identities/create', {
                username,
                claim: Object.assign(Object.assign({}, claim), { type: claimType })
            });
        });
    }
    /**
     * Search for identities in the system and returns a list of existing identities.
     * @param username
     * @returns
     */
    search({ type, username, registrationDate, limit, index }) {
        return __awaiter(this, void 0, void 0, function* () {
            const param = registrationDate != undefined ? { 'registration-date': registrationDate } : {};
            return yield this.get('identities/search', Object.assign(Object.assign({ type, username }, param), { limit, index }));
        });
    }
    /**
     * Get information (including attached credentials) about a specific identity using the identity-id (DID identifier).
     * @param id
     * @returns
     */
    find(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`identities/identity/${id}`, {});
        });
    }
    /**
     * Register an existing identity into the Bridge. This can be used if the identity already exists or it was only created locally. Registering an identity in the Bridge makes it possible to search for it by using some of the identity attributes, i.e., the username.
     * @param identity
     * @returns
     */
    add(identity) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.post('identities/identity', identity);
        });
    }
    /**
     * Update claim of a registered identity.
     * @param identity
     * @returns
     */
    update(identity) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.put('identities/identity', identity);
        });
    }
    /**
     * Removes an identity from the Bridge. An identity can only delete itself and is not able to delete other identities. Administrators are able to remove other identities. The identity cannot be removed from the immutable IOTA Tangle but only at the Bridge. Also the identity credentials will remain and the identity is still able to interact with other bridges.
     * @param id
     * @param revokeCredentials
     * @returns Null
     */
    remove(id, revokeCredentials = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.delete(`identities/identity/${id}`, { 'revoke-credentials': revokeCredentials });
        });
    }
    /**
     * Get the latest version of an identity document (DID) from the IOTA Tangle.
     * @param id
     * @returns
     */
    latestDocument(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`verification/latest-document/${id}`);
        });
    }
    /**
     * Adds Trusted Root identity identifiers (DIDs). Trusted roots are DIDs of identities which are trusted by the Bridge. This identity DIDs can be DIDs of other organizations. By adding them to the list Trusted Roots their Verifiable Credentials (VCs) are automatically trusted when checking at the Bridge.
     * @param trustedAuthority
     * @returns
     */
    addTrustedAuthority(trustedRootId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post('verification/trusted-roots', { trustedRootId });
        });
    }
    /**
     * Returns a list of Trusted Root identity identifiers (DIDs). Trusted roots are DIDs of identities which are trusted by the Bridge. This identity DIDs can be DIDs of other organizations. By adding them to the list Trusted Roots their Verifiable Credentials (VCs) are automatically trusted when checking at the Bridge.
     * @returns
     */
    getTrustedAuthorities() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get('verification/trusted-roots');
        });
    }
    /**
     * Remove Trusted Root identity identifiers (DIDs). Trusted roots are DIDs of identities which are trusted by the Bridge. This identity DIDs can be DIDs of other organizations. By adding them to the list Trusted Roots their Verifiable Credentials (VCs) are automatically trusted when checking at the Bridge.
     * @param trustedAuthorityId
     * @returns
     */
    removeTrustedAuthority(trustedAuthorityId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.delete(`verification/trusted-roots/${trustedAuthorityId}`, {});
        });
    }
    /**
     * Verify the authenticity of an identity (of an individual, organization or object) and issue a credential stating the identity verification status. Only previously verified identities (based on a network of trust) with assigned privileges can verify other identities. Having a verified identity provides the opportunity for other identities to identify and verify a the entity they interact to.
     * @param initiatorVC
     * @param targetDid
     * @param claim
     * @returns
     */
    createCredential(initiatorVC, targetDid, credentialType, claimType, claim) {
        return __awaiter(this, void 0, void 0, function* () {
            let body = {
                subject: {
                    id: targetDid,
                    credentialType,
                    claim: Object.assign({ type: claimType }, claim)
                },
                initiatorVC: initiatorVC
            };
            return yield this.post('verification/create-credential', body);
        });
    }
    /**
     * Check the verifiable credential of an identity. Validates the signed verifiable credential against the Issuer information stored onto the IOTA Tangle and checks if the issuer identity (DID) contained in the credential is from a trusted root.
     * @param credential
     * @returns
     */
    checkCredential(credential) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post('verification/check-credential', credential);
        });
    }
    /**
     * Revoke one specific verifiable credential of an identity. In the case of individual and organization identities the reason could be that the user has left the organization. Only organization admins (with verified identities) or the identity owner itself can do that.
     * @param credential
     * @returns
     */
    revokeCredential(credential) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.post('verification/revoke-credential', credential);
        });
    }
}
exports.IdentityClient = IdentityClient;
//# sourceMappingURL=identity.js.map